---
layout: post
title: 운영체제 Chapter 1 요약
subtitle: Abraham Silberschatz Operating system 10th Ed.
tags: [OS]
comments: true
author: Hank Kim
thumbnail-img: https://images.unsplash.com/photo-1518709268805-4e9042af2176?w=800&h=600&fit=crop
---

I. 컴퓨터란

A. 컴퓨터의 정의

1. 최소 구성요소: CPU와 메모리

2. 최소한의 하드웨어와 소프트웨어가 존재하는 모든 것(세탁기, 냉장고 등)

B. 컴퓨터의 분류

1. 서버: 다수의 사용자의 요청을 받아서 처리하는 고성능 컴퓨터

2. PC 범용, 개인용 컴퓨터

3. 임베디드: 특정 용도에 맞게 개발한 컴퓨터

C. Computer system Component

1. computer hardware -\> operating system -\>
   system and application programs(compiler, assembler, text editor, database system..) -\> users

D. Computer System Organization

1. CPU, 메모리, 입출력장치(I/O Device == 디스크도 포함)

2. 버스를 통해 메모리에 연결됨

3. 버스 topology이기 때문에 한번에 한 페어만 통신이 가능하다

E. Modern PC Architecture

1.North Bridge: 메모리와 연결되어있는 컨트롤러로 버스의 대역폭이 크고 빠르다.

2. South Bridge: 주변장치 버스 컨트롤러이다. 버스의 대역폭보다 디스크의 속도가 더 느리기 때문에 bottleneck이 발생한다. 따라서 North Bridge와 비교해서 버스의 대역폭이 작다.

3. CPU: 컴퓨터를 동작시키는 주체. 데이터 저장이나 불러오기 출력 등의 명령을 모두 CPU가 내린다. 입출력장치들이 동작하도록 명령을 내리는 주체도 CPU이다. 직접적으로 디바이스에 명령을 내리는것이 아니라 컨트롤러를 통해 명령한다. 디테일한 작업들은 컨트롤러가 수행하고 CPU에 보고한다.

4. CPU, 메모리,IO디바이스 컨트롤러는 버스로 연결되어있고 IO디바이스는 컨트롤러에 연결된 형태.

II. 운영체제란

A. 운영체제의 역할

1. Abstraction: 운영체제는 하드웨어 리소스 매니저. 하드웨어 자원을 관리하고 하드웨어 사용을 쉽게 해주는 인터페이스를 제공하여 유저가 하드웨어를 쉽게 사용할 수 있도록 Abstraction을 제공한다.

2. Sharing: 여러 프로세스가 하드웨어 리소스를 공유해서 사용해야 하므로 효율적으로 리소스를 공유해서 사용할 수 있도록 time multiplexing, space multiplexing 기능을 함. space multiplexing은 메모리 공간을 잘 나눠서 쓰는 것이고 time multiplexing은 여러개의 프로세스가 동시에 동작하는 것처럼 보이도록 리소스를 분배.

3. Protection: 하드웨어 자원 보호. ex) 포인터를 잘못 사용해서 잘못된 메모리 주소 참조 문제 등

4. Fairness: 한 프로세스가 독점적으로 리소스를 사용하지 않도록 함. 하나의 프로세스가 독점하면 다른 프로세스가 프리징된다.

5. Performance: 최고의 성능을 내는것을 지향해서 동작한다.

B. 운영체제를 지칭하는 용어

1. Resource Allocator

2. Kernel == 알맹이. 가장 많이 쓰는 용어. 넓은 의미에서 GUI, 시스템 어플리케이션을 포함해서 OS라고 부르고 리소스 매니징의 핵심적인 기능을 수행하는것을 커널이라고 부름.

3. Control Program

III. 컴퓨터 시스템의 동작

A. CPU 구조

1. ALU: Arithmetic Logic Unit. 논리연산 유닛이라고 하며 일반적인 연산을 담당

2. CU: Control Unit. Instruction을 수행하는 유닛.

3. MMU: memory management Unit. CPU가 메모리 접근하는것을 관리. 가상화 기능을 제공하고, 잘못된 참조가 일어났을 때의 판단 등의 메모리와 관련된 역할을 한다.

4. Registers

PC: Program Counter. 현재 어디의 instruction을 수행해야하는지의 위치를 저장.

IR: Instruction Register. 현재 수행중인 명령어를 저장함

SP: Stack Pointer 스택의 TOP주소를 저장한다.

PSW: Process status word 프로세스의 상태(waiting, ready 등)을 저장.

B. 폰 노이만 아키텍쳐

1. 현대에 사용하고 있는 대부분 컴퓨터의 하드웨어 구조.

2. 하나의 메모리 안에 코드와 데이터를 함께 넣어놓고 사용한다.

3. 다른 대표적인 아키텍쳐로 하버드 아키텍쳐가 있음. 메모리에 대한 버스를 따로 두고 한쪽에는 코드, 한쪽에는 데이터만 가져옴으로써 두 개의 메모리에서 병렬적으로 가져올 수 있다. 하지만 메모리를 할당하기 복잡하고 하드웨어의 설계도 복잡하다. 별도의 버스와 IO장치가 필요하기 때문이다. 임베디드 장치에서 하버드 아키텍쳐와 유사한 XIP구조를 사용한다.

C. Bootstrapping (리눅스)

1. 전원이 들어오면 cpu가 가장먼저 동작해서 제대로 돌아갈 수 있는 상태인지 스스로 체크한다.

2. 샘플코드를 롬에서 가져와서 테스트를 돌린다. 샘플코드 끝에는 바이오스로 이동하도록 지정되어있음.

3. 바이오스(롬 혹은 플래시로 되어있다 Basic Input Output System = BIOS) 메모리, 기본 입출력 디바이스 잘 동작하는지 체크한다. 메모리를 0부터 max번지까지 초기화해본다. 바이오스에는 필수적인 하드웨어 테스트 코드들이 적혀있다. 이러한 테스트 과정을 POST power on self test 라고 한다. 바이오스와 동일하게 POST를 수행하는 것으로 UEFI(Unified Extensible Firware Interface)가 있다.

4. BIOS/UEFI는 마지막으로 부트로더를 실행시킨다. 부트로더는 LILO/GRUB가 있다. LILO(Linux Loader)는 시작점을 MBR애 저장한다. 업데이트하면 시작점이 달리질 수 있기 때문에 업데이트 때마다 MBR을 계속 갱신해야하고 깨지면 부팅이 안되기 때문에 신뢰성이 떨어진다.GRUB은 압축되어있는 이미지의 시작점을 주솟값보다 안정적인 벡터값으로 가리키도록 해서 LILO의 문제점을 해결했다.

5. 부트로더는 여러개의 운영체제 시작점을 가지고 있고 실행시킬 운영체제를 선택하면 압축되어있던 운영체제를 메모리로 로드하고 압축을 풀어서 실행시킨다.

D. Instruction Set Architecture(ISA)와 성능향상을 위한 아키텍쳐

1. CISC/RISC: CISC는 Complex Instruction Set Computer이고 RISC는 Reduced Instruction Set Computer이다. CISC는 많이 사용되는 Instruction조합에 대해서 하나의 Set을 만들어 성능을 높이는 방식이다. 하지만 CPU에 많은 Instruction Set회로를 구현하려다 보니 복잡해지기 때문에 한계가 존재한다. CPU크기가 커질수록 오히려 성능은 저하될 수 있다. 회로가 길어지면 느려지고 발열도 많이 발생하기 때문이다. 그래서 기본적인 Instruction들로만 CPU를 구성한것이 RISC이다. 현재 둘 다 사용하고 있다. x86시스템은 CISC를 사용하고, ARM코어는 RISC를 사용한다.

2. Pipelining: RISC에서는 효율적으로 명령을 수행하기위해서 pipelining을 사용한다. CPU의 수행과정은 1. Fetch – 프로그램카운터가 가리키고 있는 Instruction을 로드. 2. Decode – 명령을 전기신호로 바꿈. 3.Execution 4. Write Back – 결과값을 내놓음. 4가지 과정으로 이루어진다. 각각의 과정들의 Dependency가 존재하지 않으므로 동시에 수행되어도 문제가 없다. 이론적으로는 4개를 병렬적으로 수행할 수 있으나 성능을 4배 향상시키지는 못한다. 그 이유는 1. 명령별로 Execution Time이 다를 수 있기 때문에 지연이 발생. 2. 앞의 연산을 수행한 결과가 다음 명령의 Input값으로 사용되는 경우가 존재. 3. 분기(조건문) 이 존재할 경우 다음에 수행될 명령어가 무엇이 될지 알 수 없음. 이러한 이유로 실제로는 2.3배정도의 성능향상 효과가 있다고 알려져있다.

3. ILP(Instruction-Level-Parallelism): 명령어를 병렬적으로 수행하기 위한 방법으로 Superscalar와 VLIW가 있다. Superscalar는 CPU에서 하드웨어적으로 구현하는 방법으로 인텔에서 사용한다. VLIW는 컴파일 과정에서 코드를 분석해서 동시에 수행할수 있는것들을 리스트업함으로써 소프트웨어적으로 구현한 방법이다.

4. Simultaneous Multithreading: 실제 코어는 하나지만 가상코어를 여러개 만드는 방법이다. 미약한 성능향상효과가 있다.

5. MultiCore: 레지스터와 Cache는 각자 가지고 메모리는 공유하는 물리적인 CPU를 여러개 붙이는것이 멀티코어 아키텍쳐이다. 요즘은 대부분의 컴퓨터가 멀티코어 아키텍쳐를 사용한다.

6. NUMA(Nom-Uniform Memory Access) multiprocessing Architecture: . 물리적인 CPU마다 메모리를 따로 가지고 하나의 시스템안에서 공유하는 아키텍쳐이다. 병렬 컴퓨팅을 극대화할수 있고 사용되는 대표적인 예로는 기상청 슈퍼컴퓨터가 있다.

7.Clustered System Architecture = Distributed System: 완전히 분리된 컴퓨터를 네트워크로 연결하고 일을 분배하면서 동작하는 분산 시스템이다. 대용량의 스토리지를 공유한다. 각각의 컴퓨터들은 Parallel 시스템으로 구현될 수 있다. AWS를 예로 들 수 있다.

E. I/O 동작 순서

1. CPU는 IO디바이스와 연결된 컨트롤러를 통해서 IO관련 명령을 내리고 컨트롤러가 해당 명령을 수행한다. 컨트롤러는 IR(Instruction Register)와 DR(Data Register)를 가지고 있다. IO를 수행할때 IO를 두고 다음 작업을 수행하는 것을 Async/Non-blocking IO라고 하고, IO가 끝날때까지 프로세스가 기다리는 것을 Synchronous/Blocking IO라고 한다. 대부분은 Blocking IO에 해당한다.

2. 컨트롤러가 HDD에서 메모리를 가져와서 로드하는 등의 IO작업을 기다리는 동안 CPU는 Context를 저장해두고 다른 프로세스를 실행시킨다. CPU Utilization을 극대화하기 위해서이다.

3. IO컨트롤러가 명령을 다 수행했을때 CPU에게 완료됐다는 신호를 준다. 이를 하드웨어 인터럽트라고 한다.

4. 하드웨어 인터럽트가 들어오면 CPU는 현재 진행중이던 프로세스의 여러 값들을 저장해두고 CPU에서 내린다.

5. 이후 운영체제가 올라와서 인터럽트 핸들링 코드를 수행한다.

6. 완료되면 스케줄링을 통해서 선정된 다른 프로세스를 수행한다.

F. DMA (Direct Memory Access)

1. 정의: 하드디스크에서 데이터를 가져올 때 버스의 bandwidth가 정해져 있기 때문에 용량이 크면 한번에 로드할 수 없다. 64비트 컴퓨터라면 버스의 크기도 64비트이다. CPU가 큰 데이터를 버스의 크기로 쪼맨 것을 들고 오라는 명령을 계속해서 내리는것은 오버헤드가 크다. 따라서 CPU를 거치지 않고 바로 메모리로 올려주기 위해서 사용하는것이 DMA이다.
2. 순서: CPU에서 컨트롤러에 용량이 큰 데이터를 로드하라는 명령을 내림 -\> 컨트롤러에서 DMA를 지원하는 하드웨어일 경우 DMA를 사용해야겠다는 판단이 들 경우 DMA에게 CPU에게 허락을 받아달라고 요청 -\> DMA가 CPU에게 요청하고 CPU가 승인하면 매 fragment마다 인터럽트를 걸어서 CPU가 처리하지 않고 DMA가 권한을 받아 디스크 컨트롤러는 DMA에 보고하고 메모리로 데이터를 올린다. 이로인해 CPU의 오버헤드가 많이 줄어든다.

G. 인터럽트

1. 넓은 의미의 인터럽트: 하드웨어 인터럽트, Trap , exception.
2. 하드웨어 인터럽트: 하드웨어 기기에 의해 생성된 인터럽트. 타이머 인터럽트, 키보드 인터럽트 등이 해당한다.
3. Trap : 라이브러리 형태로 커널이 제공하는 함수 시스템콜을 호출하면 현재 진행중인 프로세스를 중단하고 운영체제가 올라온다. 시스템 콜을 호출해서 운영체제가 올라오는것을 trap이라고 함
4. exception: CPU가 스스로 거는 인터럽트이다. Divide by Zero로 인한 fault exception 등.

H. 스토리지

1. ROM vs RAM: ROM은 Read Only Memory, RAM은 Random Access Memory로 일반적으로 DRAM을 지칭한다. ROM은 CD처럼 한번 데이터 넣고 나면 수정이 불가능하다. 굽는다고 표현한다. 용량이 크지 않고 바이오스를 넣을때 많이 사용했었다.
2. SRAM vs DRAM: SRAM은 Static RAM이고 DRAM은 Dynamic RAM이다. SRAM의 가격이 더 비싸다. CPU레지스터 혹은 캐시는 SRAM을 사용한다. SRAM이 더 빠르기 때문이다. 메모리는 휘발성이 있는데 SRAM은 전원이 공급된다는 전제하에서 한번 저장된 데이터가 사라지지 휘발되지 않는다. 반면 DRAM은 일정시간이 지나면 데이터가 망가지기 때문에 리프레시를 계속 해줘야한다. 리프레시 중에는 메모리 엑세스가 불가능해 SRAM에 비해서 성능이 좋지 않다. DRAM은 신호가 점점 희미해지는 구조를 가지고 있다.
3. 계층구조: (최상) 레지스터 -\> 캐시 -\> DRAM(메인 메모리) -\> Solid-State-Disk(SSD) -\> Hard Disk -\> Optical Disk(CD) -\> Magnetic Tape (최하). 아래로 갈수록 가격이 싸지고 용량은 늘어난다.
4. Caching Policy: Write-through vs Write Back. Write Through는 CPU가 메모리에서 데이터를 읽어서 연산을 수행한 결과를 메모리에 저장할때 즉시 Disk에 있는 데이터도 변경하는 방식이다. 메모리와 디스크의 일관성을 유지할 수 있지만 CPU Utilization이 떨어져서 성능에 영향을 미친다. Write Back은 CPU가 유휴상태인 경우에 바뀐 내용을 한꺼번에 반영하는 방식이다. 성능은 좋지만 일관성이 떨어질 수 있다. 컴퓨터가 꺼지면서 데이터가 날아가는 등의 경우가 발생할수도 있다. 폰 노이만 아키텍쳐와 하버드 아키텍쳐의 캐싱 성능을 비교하면 하버드 아키텍쳐의 성능이 더 좋다.
5. HDD 구조: 플래터 - 은색의 판 한장. Surface - 데이터가 기록되는 표면. Arm - 플래터마다 하나씩 존재하며 끝에 데이터를 읽을수 있는 핀인 Head가 존재. Arm이 움직이면서 특정 지점의 데이터를 읽는다. Track - arm들이 움직이면서 데이터를 저장하는 동심원. Sector- Track의 일부분. 512바이트만큼의 크기를 가진다. 디스크에 저장되는 데이터 크기의 최소단위이다. 몇 번 플래터의 트랙, 섹터를 알면 암을 움직여서 데이터를 읽어올 수 있다.
   실린더: 각 플래터의 똑같은 위치의 트랙들의 모음.
6. HDD 데이터를 읽기 위한 3가지 단계: 1. Arm Seek - arm이 원하는 트랙으로 이동한다. 2. 돌고있는 플래터에 헤드를 내려서 데이터를 가져온다. 3. 읽은 데이터가 버스를 타고 메모리에 전달된다.
   이중에서 가장 느린 동작은 arm seek이다. 이 시간을 최소화해야 하드디스크의 속도를 개선할 수 있다. 이것을 위해서 데이터를 최대한 모아서 연속적으로 한 플래터, 연속적인 트랙에 저장한다. 또한 같은 실린더에 데이터를 연속적으로 쓰면 armseek시간을 최소화할 수 있다. 디스크 조각모음이라는 윈도우의 기능이 있었는데, 이것이 armseek 시간을 최소화하기 위한 기능이었다.
7. SSD: 플래시 컨트롤러와 NAND 플래시 메모리로 구성되어 있다. 전력 공급이 되지 않아도 데이터가 남아있고 랜덤 액세스가 가능하다. NAND플래시는 블럭으로 되어있는데, 블럭 하나당 데이터를 지우고 다시 쓸 수 있는 횟수가 정해져있다. 하나라도 동작하지 않으면 전체를 사용할 수없기 때문에 웨어레벨링 기능이 구현되어있다.

I. 시스템 콜과 프로텍션

1. Dual Mode Operation: Kernel mode/User mode로 나뉜다. User mode에서 프로세스가 운영체제로 trap 인터럽트를 걸면 운영체제가 IO디바이스를 컨트롤한다. 하드웨어에 대한 권한은 Kernel Mode가 갖는다. IO작업이 완료되면 하드웨어 인터럽트로 인해서 운영체제가 다시 동작하고 프로세스로 전달된다. User Mode에서 Kernel Mode로 요청할 수 있는 인터페이스가 시스템콜 == 트랩이다.
2. 하드웨어 프로텍션: 운영체제가 모든 권한을 가지고 하드웨어를 관리하며 한 프로세스가 리소스를 독점하는 등의 상황을 막는것이 Protection이다. CPU Protection은 한 프로세스가 계속해서 CPU를 점유하는 것을 방지하기 위한 것으로, CPU안에 타이머가 하드웨어로서 존재한다. 리눅스 기준으로 10ms이며 사용한 시간이 10ms에 도달하면 자기 자신에게 인터럽트를 걸어 해당 프로세스 작업 내용을 저장해두고 스케줄러 정책에 의해 선정된 다른 프로세스를 가져와서 실행한다. 메모리 프로텍션은 포인터로 다른 프로세스의 메모리에 허락없이 접근하는 것과 같은 상황에서 프로세스를 kill하는 정책이다. IO프로텍션은 운영체제를 통해서만 IO디바이스를 사용할 수 있도록 하는 것으로 dual mode operation에 해당한다.
3. OS가 시스템을 제어하는 경우는 부트스트래핑, 시스템콜 (프로세스가 IO디바이스 사용요청) , 인터럽트(하드웨어 인터럽트는 IO디바이스, CPU 타이머가 요청)가 발생한 경우로 요약할 수 있다.

IV. 컴퓨터의 역사

1. 1세대 (1945~1955)

1. 애니악: 존 폰 노이만이 설계했다. 진공관에 전기신호를 넣어서 0,1 조합을 만들었다. OS가 존재하지 않았고 프로그래밍 언어도 없었다.

B. 2세대(1955~1965)

1. 진공관에서 트랜지스터로 바뀌면서 크기가 줄어들었다. Batch System이 존재했다. OS라고 불리지 않고 Resident Monitor라고 불렸다. IO중에 다른 작업을 수행할 수 없고 프로세스 하나가 끝나야 다른 것을 실행시킬 수 있었기 때문에 입출력 bottleneck이 컸다.

C. 3세대(1965-80)

1. 집적회로 IC를 사용했다. 컴퓨터 아키텍쳐라는 개념이 생겨났다. IBM의 IBM360이 해당한다
2. IO를 하는 동안 CPU가 다른 작업을 할 수 있게 하는 멀티프로그래밍 시스템을 적용해서 CPU Utilzation을 늘렸다. Fairness를 보장하기 위해서 Time-sharing system을 적용하여 response time 을 줄였다. 현재까지도 중요하게 사용되는 2가지 개념이 적용된 전통적인 OS의 특징이 되었다.

D. 4세대(현재)

1. IC를 더욱 작게 만들어서 (LSI, VLSI) 데스크탑 PC가 생겨났다.
2. 현대 OS의 기능으로는 GUI, 멀티미디어(음악,영상 등) 인터넷과 웹 등이 있다.

V. 컴퓨팅 환경

1. Traditional computing

1. 메인프레임 시스템: 배치시스템이나, 멀티프로그래밍, 타임쉐어링 기능 제공하는 은행 서버 등이 해당
1. 데스크탑 시스템

B. 모바일 컴퓨팅

1. 특징: 메모리와 프로세서 기능이 제한되어있고 디스플레이도 작다

C. 실시간 시스템

1. 정의: 정해진 시간 내에 정해진 일을 끝내야 하는 시스템
2. Hard Real-time vs Soft Real-time: Hard Real-time은 항공기 컨트롤 시스템 등 반드시 정해진 시간내에 끝내야하는 시스템이다. Soft Real-time시스템은 게임서버, 비디오 스트리밍 등이 해당한다.

D. 임베디드 시스템

1. 특정 목적을 위해서 설계된 시스템이다. 목적을 수행할 수 있는 최소한의 하드웨어를 가지고 있다.

E. 클라이언트-서버 컴퓨팅

1. 일반적으로 데이터센터에 네트워크 연결된 서버가 존재하고 서버가 제공하는 서비스를 클라이언트가 받아와서 수행한다. Clustered Server로 병렬, 분산 컴퓨팅을 사용

F. Peer-to-Peer 컴퓨팅

1. ad-hoc이라고도 하며 이미 구축된 네트워크에 붙는게 아니라 네트워크를 만들어서 통신한다. 인터넷에 연결될 필요가 없다.

G. 클라우드 컴퓨팅

1. Iaas: Infrastructure as a service. 하드웨어 자원만을 제공한다
2. Paas: Platfor as a Service. 예를 들어리눅스 기반 OS 등을 제공하고 그 위에 프로그램을 만드는 경우.
3. Saas: Software as a Service. 서비스 단위로 구현된 아이클라우드 등.
4. 가상화 기술이 중요하다. 컴퓨팅 파워를 묶어서 재분배할 수 있도록 가상화 클라우드를 사용한다.

H. 가상화

1. 대표적인 가상화로 jvm이 있다. .java목적파일을 vm을 통해서 바이너리를 생성하고 실행한다.
2. 하드웨어 자원을 나눠쓰고 각 vm위에 커널이 올라간다.

VI. 운영체제의 역사

1. IBM 360

1. 멀티프로그래밍 제공

B. MIT CTSS

1. 타임 쉐어링 시스템

C. UNIX (1969)

1. 어셈블리로 만들어졌고 71년에 C로 컨버팅되었다. BELL Lab에서 만든 오픈소스이며 C언어 또한 BELL LAB에서 개발했다.
2. 유닉스를 계승한 운영체제: AT&T에서 System 5, 버클리에서 BSD를 만들었고 BSD를 계승한 SunOS가 나왔다. SunOS가 발전해서 Solaris가 되었다. Unix 7th edition을 계승해서 Xenix. BSD에서 MACH - NextStep이 나오고 스티브 잡스가 인수하여 macOS X의 기반이 되었다.
   93년도 경에 리눅스가 나왔다. HP, IBM AIX등 여러 OS가 유닉스 계열이다.
3. POSIX: 같은 유닉스 계열의 OS중에서 시스템 콜 형식이 달라서 호환이 안되는 경우가 발생하지 않도록 만든 표준. POSIX를 따르는 OS는 시스템콜이 동일하다.

D. 윈도우

1. Batch System을 기반으로 시작했다. 유닉스 계열이 아니다.

E. 리눅스

1. 리누즈 토발즈가 개발했으며 무료 소프트웨어 개념은 GNU 프로젝트를 이어서 완전히 오픈소스인 OS이다. 안드로이드, iOS도 리눅스 기반이다. 서버, 임베디드 등 많은 곳에서 사용되고 있다. 임베디드에서 사용되는 가장 대표적인 높은 신뢰성의 운영체제로 VxWorks가 있다. 항공산업 등에서 사용된다.
